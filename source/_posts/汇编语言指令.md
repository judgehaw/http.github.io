---
title: 汇编之指令篇
copyright: true
date: 2020-12-31 11:19:30
tags: "汇编"
categories: "汇编"
---

### mov指令：经常做为为寄存器或内存中赋值的指令

​	例：mov ax,1000H	表示将AX寄存器中的内容修改为1000H

### add指令：加法指令

​	例：mov ax,30H	表示将AX寄存器中的内容加上30H后赋值给AX寄存器

### sub指令：减法指令



### div指令：除法指令

​	除数：有8位和16位两种，在一个寄存器或内存单元中

​	被除数：默认放在AX或AX和DX中

​		如果除数为8位，被除数为16位，则默认存放在AX中

​		如果除数为16位，被除数为32位，则DX存放高16位，AX存放低16位

​	结果：

​		如果除数为8位，则AL存放除法的操作的商，AH存放除法操作的余数

​		如果除数为16位，则AX存放出发操作的商，DX存放除法操作的余数

### mul指令：乘法指令

​	分为8位乘法和16位乘法

​	如果是8位，一个数字存放在AL中，另一个数字存放在其他8位寄存器或字型内存单元中.

​	如果是16位，一个数字默认存放在AX中，另外一个数字存放在其他16位寄存器或字型内存单元中。

​	结果：如果是8位乘法，得到一个16位数值，结果存放在AX中，如果是16位乘法，得到一个32位数值，结果存放在AX和DX中，DX存放高16位，AX存放低16位。



### push指令：入栈指令

​	例：push ax		表示将AX寄存器中的内容入栈，并修改栈顶标记

### pop指令：出栈指令

​	例：pop ax		表示将栈中低位一个字形数据出栈并赋值给AX寄存器

### inc指令：增加1

​	例：inc ax		表示将寄存器AX中的内容加1，相比add指令加1会节约内存

### dec指令：减去1

​	例：dec bx		表示将bx寄存器中的值减去1

### and指令：与运算

​	例：

​		mov al,00001111B

​		and al,10001010B

​		结果为al = 00001010 = 0AH

​	与运算，将相对应的为两个为1，则结果才为1，只要有一个位的值为0，则结果为0，可用于大小写转换

### or指令：或运算

​	例：

​		mov al,00001111B

​		or al,11110000B

​		结果为al = 11111111B = FFH

​	或运算，将相对应的位只要有一个是1，则运算结果为1，可以将相对应的位设置为1，其他位不变

### dup指令：重复伪指令，通常配合DB,DW,DD使用，用来在数据段或栈段定义数据或栈的大小

​	例： 

​	data segment

​		db 	10dup(0)

​		dw	10dup('123','abc')

​		dd	10dup(0)

​	data ends

### OFFSET：操作符，伪指令，用来取得标号处的偏移地址

​	例：mov ax,OFFSET start	取得start标号处的偏移地址并赋值给AX寄存器

## 转移指令：

### jmp指令：转移指令，通过修改IP寄存器或CS和IP寄存器的值，来决定CPU从哪里来读取指令

#### 	原理：

​	jmp指令编译后的机器码和指令长度有关，通过这种方式CPU在执行JMP指令的时候不需要跳转的目的地址就可以直线对IP寄存器的修改，只要做一个加法就好了。

​	例：

​	jmp s	这里内存中的数据为EB07

​	mov bx,1000H

​	mov bx,1001H

​	mov bx,1002H

  s：	mov ax,1000H

​	在内存中jmp s显示的16进制数为EB07，这里的07代表了jmp指令后第一个字节的偏移地址与标号处的偏移地址相差的字节数

​	问题：为什么是jmp指令后的第一个字节的偏移地址呢？为什么jmp指令CPU只需要做一个加法就好了？：

​	   因为CPU执行指令的过程，是先将jmp指令保存在指令缓存器中，然后IP寄存器加上所读指令的长度指向下一条指令的位置后，再去执行当前指令缓存器中的指令，所以是IP寄存器已经改变为下一条指令的偏移地址。

​	    在执行jmp指令后，再次修改IP寄存器的值来实现跳转，这个值是直接通过加法来计算出来jmp跳转的位置的。EB07这里的07就代表了执行jmp指令的的IP寄存器中的值，也就是下一条指令的偏移地址，加上07后的位置。

​	   相反，这个07位置的地址就是标号地址减去jmp指令后第一个字节的地址。

​	计算机中是没有减法的，我们的减法指令或者减法计算是通过加上一个负数来计算减法的：

​		这个负数是通过补码的方式来得到的，补码就是将一个正数变成二进制后按位取反（0变1，1变0）后，加上1

​		例：-5：  5 = 0000 0101		取反后为11111010，然后加上1等于11111011，也就是FB

#### 	jmp指令的跳转范围：

​	     8位位移：-128~127

​	     16位位移：-32768~32767

​	指定8位位移可直接在指令中写：jmp short s

​	指定16位位移可直接在指令中写：jmp near ptr s

​	jmp转移的目的地址在内存中：

​	    我们可以将jmp后跳转的偏移地址修改为内存中的某个数据，然后这个数据会覆盖IP寄存器或CS和IP寄存器，使用如下指令：

​		jmp word ptr ds:[0]/ds:[bx]

​		jmp dword ptr ds:[0]/ds:[bx]

​	     如上指令，我们将ds:[0]或ds:[bx]位置的字形数据用作jmp指令跳转的偏移地址。

​	     dword ptr 指的是两个字形数据，这时将同时修改CS和IP寄存器，修改的内容为IP寄存器覆盖数据位置的低位字节，CS寄存器覆盖数据位置的高位字节

​	"jmp far ptr 标号"实现的是段间转移，又成为远转移，同时修改CS和IP寄存器的值，段内转移是只修改IP寄存器的值。

jcxz指令：条件转移指令，j-->jmp,cx-->cx寄存器,z-->zero

​	当CX寄存器中的值为0的时候进行跳转。

​	所有条件转移指令，都是短转移，唯一范围：-128~127

### loop指令：条件转移指令。指令后跟标号。

​	loop指令原理：首先将CX中的值减去1，再判断CX寄存器中的值是否为0，等于0的话执行下面的指令，不等于0的话继续循环执行

### ret指令和retf指令：

​	当执行ret指令时，相当于执行了pop ip，也同时修改了栈顶标记。

​	当执行retf指令时，相当于执行了pop ip后执行pop cs，并修改栈顶标记。

### call指令及用法：

​	call指令执行的步骤相当于先执行push ip，这里的IP寄存器中的值为call指令的下一条指令第一个字节的偏移地址，然后执行jmp near ptr 标号，说明call指令的转移方式也是位移的方式，但是是16位位移，位移范围-32768-32767.位移是在编译的时候编译器计算的。

​	call指令通常配合ret或retf指令做为代码的组织和逻辑的切割

​	转移的目的地址在指令（机器码）中的call指令：

​		call far ptr 标号

​		过程：

​		push cs

​		push ip

​		jmp far ptr 标号	CS = 标号所在段的段地址	IP = 标号所在段的偏移地址

​	转移的目的地址在寄存器中的call指令：

​		call 寄存器

​		过程：

​		push ip	push call指令后第一个字节的偏移地址

​		jmp 寄存器

​	转移的目的地址在内存单元中的call指令：

​		call word ptr 内存单元地址

​		过程：

​		push ip

​		jmp word ptr 内存单元地址

​		call dword ptr 内存单元地址

​		过程：

​		push cs

​		push ip

​		jmp dword ptr 内存单元地址

